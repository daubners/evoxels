#%% Test usage
import voxelsss as vox
import numpy as np
import time
%matplotlib qt

#%%
nx, ny, nz = [100, 100, 20]

sim = vox.voxelFields(nx, ny, nz, (1,1,1))

# cube = np.zeros((nx, ny, nz))
# cube[5:-5,5:-5,5:-5] = 1
# sim.add_field("cube", cube)

# diagonal = np.zeros((nx, ny, nz))
# x, y, z = np.ogrid[:nx, :ny, :nz]
# plane = (x+0.5)/nx + (z+0.5)/nz + y - y
# mask = (plane <= 1.0)
# diagonal[mask] = 1
# sim.add_field("diagonal", diagonal)

# diagonal2 = np.zeros((nx, ny, nz))
# x, y, z = np.ogrid[:nx, :ny, :nz]
# plane = (x+0.5)/nx + (y+0.5)/ny + (z+0.5)/nz
# mask = (plane <= 1.05) | (plane > 2.0)
# diagonal2[mask] = 1
# sim.add_field("diagonal2", diagonal2)

# sphere = np.zeros((nx, ny, nz))
# radius = np.min([nx,ny,nz])*0.5-3
# x, y, z = np.ogrid[:nx, :ny, :nz]
# distance_squared = (x - nx/2 + 0.5)**2 + (y - ny/2 + 0.5)**2 + (z - nz/2 + 0.5)**2
# mask = distance_squared <= radius**2
# sphere[mask] = 1
# sim.add_field("sphere", sphere)

noise = 0.5 + 0.1*np.random.rand(nx, ny, nz)
sim.add_field("noise", noise)

a = vox.CahnHilliardSolver(sim, "noise", device='cpu')
a.solve(time_increment=0.002, max_iters=10000, verbose='plot')

#%%
sim.plotFieldInteractive("diagonal", direction='x')

#%%
# Make little convergence study
# 1. Implement convergence criterion and convergence plot
# 2. Take without checkers as referenz (w=1.2??)
# 3. Take pure checkers as second reference (w=1.7??)
# 4. Play with ratio w1 to w2: 1.7:1.2, 1.95:1.1, 2.2:1.0

solver = hex.TortuositySolver(hex_plane, "mask", "c", omega1=1.70, omega2=1.2, frames=20, max_iters=10000)
solver.solve()

# slice = np.linspace(0, 1, Ny)
# hex_plane.add_field("c", np.tile(slice, (Nx, 1)))
# hex_plane.add_field("c", np.random.rand(Nx, Ny))

# hex.add_hexel_sphere(hex_plane,"mask", 0,0,0,30)
# hex.add_hexel_sphere(hex_plane,"mask", Nx/2,Ny/2,0,30)
# hex_plane.export_to_vtk()
# solver.solve()

#%%
import torch
import torch.nn.functional as F

device='cuda'
tensor = torch.tensor(hex_plane.fields["mask"], dtype=torch.float32, device=device)
tensor = tensor.unsqueeze(0).unsqueeze(0)

even_laplace_kernel = torch.tensor([[0, -1, 0],
                                    [0, 0, 0],
                                    [0, 1, 0]],
                                    dtype=torch.float32, device=device)
# even_laplace_kernel = even_laplace_kernel/3
even_laplace_kernel = even_laplace_kernel.unsqueeze(0).unsqueeze(0)

even_neighbours_kernel = torch.tensor([[1, 1, 1],
                                    [1, 0, 1],
                                    [0, 1, 0]],
                                    dtype=torch.float32, device=device)
even_neighbours_kernel = even_neighbours_kernel.unsqueeze(0).unsqueeze(0)

odd_neighbours_kernel = torch.tensor([[0, 1, 0],
                                    [1, 0, 1],
                                    [1, 1, 1]],
                                    dtype=torch.float32, device=device)
odd_neighbours_kernel = odd_neighbours_kernel.unsqueeze(0).unsqueeze(0)
# Take periodicity in x into account
padded = F.pad(tensor, (1,1,1,1), mode='circular')
even = F.conv2d(padded, even_neighbours_kernel)
odd  = F.conv2d(padded, odd_neighbours_kernel)

# Stitch even and odd columns for full neighbour field
# neighbours = torch.zeros_like(tensor[:,:,:,1:-1])
neighbours = torch.zeros_like(tensor)
neighbours[:, :, :, ::2] = even[:, :, :, ::2]
neighbours[:, :, :, 1::2] = odd[:, :, :, 1::2]

neighbours[neighbours==0] = torch.inf

# solver = hex.CahnHilliardSolver(hex_plane, "c", max_iters=100, device=device)
# solver.calc_laplace(tensor)
# test.export_to_vtk()
# test.export_to_vtk(convention="structured")
# %%
dx=1
num_x=10
num_y=10
dy = np.sqrt(3)*0.5*dx
side = dx/np.sqrt(3)

origin_x = dx
origin_y = dx/2
# x_lin = np.arange(0, 10, dtype=np.float32)*dx + origin_x
# y_lin = np.arange(0, num_y, dtype=np.float32)*dy + origin_y
# x, y = np.meshgrid(x_lin, y_lin, indexing='ij')
# x[:,::2] -= 0.5*dx

vert_x = 0.5*dx*np.arange(-1, 2*num_x+1) + origin_x
vert_y = dy*np.arange(-1, num_y) + origin_y
vert_y[::2] += 0.25 * side
vert_y[1::2] -= 0.25 * side
x, y = np.meshgrid(vert_x, vert_y, indexing='ij')
y[1::2,::2] -= 0.5 * side
y[1::2,1::2] += 0.5 * side
z = np.zeros_like(x)

points=np.stack((x.flatten('F'), y.flatten('F'), z.flatten('F'))).T
hexagons = np.zeros((7,num_x*num_y))
hexagons[0,:] = 6
vert_x = np.arange(0, num_x*num_y)
ll = 2*(vert_x%num_x) + (num_x*2+2)*np.floor_divide(vert_x,num_x) + (np.floor_divide(vert_x,num_x))%2
hexagons[1,:] = ll
hexagons[2,:] = ll+1
hexagons[3,:] = ll+2
ur = 2*(vert_x%num_x) + (num_x*2+2)*(np.floor_divide(vert_x,num_x)+1) + (np.floor_divide(vert_x,num_x))%2
hexagons[4,:] = ur+2
hexagons[5,:] = ur+1
hexagons[6,:] = ur
# %%
